# IO Module

Map persistence and export for VastuSLAM.

## Module Structure

```
io/
├── mod.rs          # Module exports and documentation
├── vastu_format.rs # Native .vastu binary format
├── pgm.rs          # ROS-compatible PGM/YAML export
├── svg.rs          # SVG visualization with trajectories
└── scenario.rs     # YAML-based test scenario definitions
```

## Format Comparison

| Format | Purpose | Preserves |
|--------|---------|-----------|
| `.vastu` | Native persistence | All cell data (type, confidence, swept) |
| `.pgm` + `.yaml` | ROS integration | Occupancy only (Free/Occupied/Unknown) |
| `.svg` | Visualization/audit | Visual map + trajectories |

## Native Vastu Format

Binary format preserving full cell information:

### File Structure

```
┌────────────────────────────────────┐
│           Header (32 bytes)        │
├────────────────────────────────────┤
│ Magic: "VASTU"         (5 bytes)   │
│ Version: u8            (1 byte)    │
│ Width: u32 LE          (4 bytes)   │
│ Height: u32 LE         (4 bytes)   │
│ Resolution: f32 LE     (4 bytes)   │
│ Origin X: f32 LE       (4 bytes)   │
│ Origin Y: f32 LE       (4 bytes)   │
│ Reserved               (6 bytes)   │
├────────────────────────────────────┤
│       Cell Data (W × H bytes)      │
│  Each byte: [type:4][flags:4]      │
│  type: 0=Unknown, 1=Floor, 2=Wall, │
│        3=Cliff, 4=Bump             │
│  flags: 0x80 = swept flag          │
└────────────────────────────────────┘
```

### Usage

```rust
use vastu_slam::io::{save_vastu, load_vastu};
use std::path::Path;

// Save map
save_vastu(map.storage(), Path::new("map.vastu"))?;

// Load map
let storage = load_vastu(Path::new("map.vastu"))?;
```

### Streaming API

```rust
use vastu_slam::io::{write_vastu, read_vastu};
use std::io::Cursor;

// Write to any Writer
let mut buffer = Vec::new();
write_vastu(&storage, &mut buffer)?;

// Read from any Reader
let mut cursor = Cursor::new(buffer);
let loaded = read_vastu(&mut cursor)?;
```

## ROS Map Export (PGM)

Creates ROS map_server compatible files:

### Gray Values

| Value | Meaning | Cell Types |
|-------|---------|------------|
| 254 | Free | Floor |
| 0 | Occupied | Wall, Cliff, Bump |
| 205 | Unknown | Unknown |

### Usage

```rust
use vastu_slam::io::export_ros_map;
use std::path::Path;

// Creates map.pgm and map.yaml
export_ros_map(storage, Path::new("map"))?;
```

### Output Files

**map.pgm** (binary grayscale image):
```
P5
# Generated by vastu-map
800 800
255
[binary pixel data]
```

**map.yaml** (ROS metadata):
```yaml
image: map.pgm
resolution: 0.025
origin: [-10.0, -10.0, 0.0]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
```

### Individual Exports

```rust
use vastu_slam::io::{export_pgm, export_yaml, write_pgm};

// Just PGM
export_pgm(&storage, Path::new("map.pgm"))?;

// Just YAML
export_yaml(&storage, "map.pgm", Path::new("map.yaml"))?;

// To any Writer
let mut buffer = Vec::new();
write_pgm(&storage, &mut buffer)?;
```

## SVG Visualization

Renders maps with trajectory overlays for auditing:

### Basic Usage

```rust
use vastu_slam::io::{SvgVisualizer, SvgConfig, markers_by_distance};
use std::path::Path;

let config = SvgConfig::default();
let visualizer = SvgVisualizer::new(storage, config)
    .with_title("SLAM Test Run")
    .with_ground_truth(gt_poses, markers_by_distance(&gt_poses, 0.5))
    .with_estimated(est_poses, markers_by_distance(&est_poses, 0.5))
    .with_odometry(odom_poses, vec![]);

visualizer.save(Path::new("output.svg"))?;
```

### Configuration

```rust
use vastu_slam::io::{SvgConfig, SvgColorScheme};

let config = SvgConfig {
    scale: 50.0,              // Pixels per meter
    trajectory_width: 2.0,    // Line width
    marker_radius: 4.0,       // Pose marker size
    padding: 20.0,            // Margin around map
    colors: SvgColorScheme {
        wall: "#333333",
        floor: "#FFFFFF",
        unknown: "#CCCCCC",
        gt_trajectory: "#22AA22",      // Green
        estimated_trajectory: "#2222AA", // Blue
        odom_trajectory: "#AA2222",    // Red
    },
};
```

### Marker Strategies

```rust
use vastu_slam::io::{markers_by_distance, markers_by_time};

// Marker every 0.5 meters traveled
let markers = markers_by_distance(&poses, 0.5);

// Marker every 1.0 seconds (given total time and pose count)
let markers = markers_by_time(poses.len(), total_time_secs, 1.0);
```

### Output Structure

The SVG includes:
- Background grid of cells (Floor/Wall/Unknown)
- Trajectory paths (lines)
- Pose markers with direction indicators
- Legend explaining colors

## Test Scenarios

YAML-based test definitions for reproducible testing:

### Example Scenario

```yaml
name: "Square Path Test"
description: "Robot drives in a 2m square"
map: "simple_room"

start_pose:
  x: 2.0
  y: 2.0
  theta: 0.0

seed:
  scans: 20
  rotation: true

commands:
  # Forward 2m
  - type: move
    linear_velocity: 0.2
    angular_velocity: 0.0
    duration_ms: 10000

  # Turn 90° left
  - type: move
    linear_velocity: 0.0
    angular_velocity: 0.5
    duration_ms: 3140

  # Repeat for square...

svg_output:
  scale: 100.0
  marker_interval_m: 0.5
  trajectory_width: 3.0
```

### Loading Scenarios

```rust
use vastu_slam::io::{Scenario, Command};
use std::path::Path;

// Load from file
let scenario = Scenario::load(Path::new("scenarios/test.yaml"))?;

println!("Running: {}", scenario.name);
println!("Duration: {:.1}s", scenario.total_duration_secs());

// Process commands
for cmd in &scenario.commands {
    let (linear, angular) = cmd.velocities();
    let duration = cmd.duration_secs();
    // Execute motion...
}

// Resolve map path
let map_path = scenario.resolve_map_path(Path::new("maps"));
```

### Command Types

```yaml
# Movement command
- type: move
  linear_velocity: 0.2    # m/s (forward positive)
  angular_velocity: 0.5   # rad/s (CCW positive)
  duration_ms: 5000       # milliseconds

# Stationary command
- type: stay
  duration_ms: 1000
```

### Seed Configuration

Initial map building before test starts:

```yaml
seed:
  scans: 20      # Number of scans to build initial map
  rotation: true # 360° rotation for full coverage
```

### SVG Output Configuration

```yaml
svg_output:
  filename: "custom_output.svg"  # Optional, defaults to scenario name
  scale: 50.0                    # Pixels per meter
  marker_interval_m: 0.5         # Distance between markers
  marker_interval_s: 1.0         # Time between markers (alternative)
  show_scan_points: false        # Show individual scan points
  trajectory_width: 2.0          # Line width
```

## Error Handling

All I/O operations return typed errors:

```rust
use vastu_slam::io::{IoError, ScenarioError};

// Vastu/PGM errors
match load_vastu(path) {
    Ok(storage) => { /* use storage */ }
    Err(IoError::Io(msg)) => eprintln!("File error: {}", msg),
    Err(IoError::InvalidFormat(msg)) => eprintln!("Bad format: {}", msg),
    Err(IoError::VersionMismatch { expected, found }) => {
        eprintln!("Version {} != {}", found, expected);
    }
}

// Scenario errors
match Scenario::load(path) {
    Ok(scenario) => { /* use scenario */ }
    Err(ScenarioError::Io(msg)) => eprintln!("File error: {}", msg),
    Err(ScenarioError::Parse(msg)) => eprintln!("YAML error: {}", msg),
    Err(ScenarioError::InvalidMap(msg)) => eprintln!("Map error: {}", msg),
}
```

## Performance Notes

| Operation | Typical Size | Time |
|-----------|--------------|------|
| Save .vastu (800×800) | ~640KB | <10ms |
| Load .vastu (800×800) | ~640KB | <10ms |
| Export PGM (800×800) | ~640KB | <10ms |
| Render SVG | Varies | <100ms |

The formats are designed for quick persistence during operation.
