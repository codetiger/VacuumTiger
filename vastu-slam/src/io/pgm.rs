//! PGM export for ROS-compatible occupancy grids.
//!
//! Exports the map in the standard ROS map_server format:
//! - PGM image file (P5 format, grayscale)
//! - YAML metadata file
//!
//! Gray values:
//! - 255: Free (Floor)
//! - 0: Occupied (Wall, Cliff, Bump)
//! - 205: Unknown

use crate::core::{CellType, GridCoord};
use crate::grid::GridStorage;
use std::io::Write;
use std::path::Path;

use super::vastu_format::IoError;

/// Gray value for free space
const FREE_VALUE: u8 = 254;

/// Gray value for occupied
const OCCUPIED_VALUE: u8 = 0;

/// Gray value for unknown
const UNKNOWN_VALUE: u8 = 205;

/// Export map as PGM image
pub fn export_pgm(storage: &GridStorage, path: &Path) -> Result<(), IoError> {
    let mut file = std::fs::File::create(path).map_err(|e| IoError::Io(e.to_string()))?;

    write_pgm(storage, &mut file)
}

/// Write PGM to a writer
pub fn write_pgm<W: Write>(storage: &GridStorage, writer: &mut W) -> Result<(), IoError> {
    let width = storage.width();
    let height = storage.height();

    // Write PGM header (P5 = binary grayscale)
    writeln!(writer, "P5").map_err(|e| IoError::Io(e.to_string()))?;
    writeln!(writer, "# Generated by vastu-map").map_err(|e| IoError::Io(e.to_string()))?;
    writeln!(writer, "{} {}", width, height).map_err(|e| IoError::Io(e.to_string()))?;
    writeln!(writer, "255").map_err(|e| IoError::Io(e.to_string()))?;

    // Write pixel data (top-to-bottom, ROS convention)
    let mut data = Vec::with_capacity(width * height);
    for y in (0..height).rev() {
        // Y is flipped in ROS
        for x in 0..width {
            let coord = GridCoord::new(x as i32, y as i32);
            let cell_type = storage.get_type(coord);
            let value = match cell_type {
                CellType::Unknown => UNKNOWN_VALUE,
                CellType::Floor => FREE_VALUE,
                CellType::Wall | CellType::Cliff | CellType::Bump => OCCUPIED_VALUE,
            };
            data.push(value);
        }
    }

    writer
        .write_all(&data)
        .map_err(|e| IoError::Io(e.to_string()))?;

    Ok(())
}

/// Export YAML metadata file (ROS map_server format)
pub fn export_yaml(
    storage: &GridStorage,
    pgm_filename: &str,
    yaml_path: &Path,
) -> Result<(), IoError> {
    let origin = storage.origin();
    let resolution = storage.resolution();

    let yaml_content = format!(
        r#"image: {}
resolution: {}
origin: [{}, {}, 0.0]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
"#,
        pgm_filename, resolution, origin.x, origin.y
    );

    std::fs::write(yaml_path, yaml_content).map_err(|e| IoError::Io(e.to_string()))?;

    Ok(())
}

/// Export both PGM and YAML files
pub fn export_ros_map(storage: &GridStorage, base_path: &Path) -> Result<(), IoError> {
    // Create PGM path
    let pgm_path = base_path.with_extension("pgm");
    let yaml_path = base_path.with_extension("yaml");

    // Get just the filename for the YAML reference
    let pgm_filename = pgm_path
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("map.pgm");

    // Export both files
    export_pgm(storage, &pgm_path)?;
    export_yaml(storage, pgm_filename, &yaml_path)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_pgm_export() {
        let mut storage = GridStorage::centered(10, 10, 0.1);

        // Set some cells
        storage.set_type(GridCoord::new(5, 5), CellType::Floor);
        storage.set_type(GridCoord::new(6, 5), CellType::Wall);

        let mut buffer = Vec::new();
        write_pgm(&storage, &mut buffer).unwrap();

        // Check header
        let content = String::from_utf8_lossy(&buffer);
        assert!(content.starts_with("P5\n"));
        assert!(content.contains("10 10\n"));
    }

    #[test]
    fn test_cell_type_to_gray() {
        // Test that the values match ROS conventions
        assert_eq!(FREE_VALUE, 254);
        assert_eq!(OCCUPIED_VALUE, 0);
        assert_eq!(UNKNOWN_VALUE, 205);
    }
}
